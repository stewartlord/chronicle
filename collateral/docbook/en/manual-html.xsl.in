<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE entities
[
    <!-- Add translated specific definitions and snippets -->
    <!ENTITY % language-snippets SYSTEM "standalone/language-snippets.xml">
    %language-snippets;

    <!-- Fallback to English definitions and snippets (in case of missing translation) -->
    <!ENTITY % language-snippets.default SYSTEM "../en/standalone/language-snippets.xml">
    %language-snippets.default;
]>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
                xmlns:fo="http://www.w3.org/1999/XSL/Format"
                xmlns:xlink="http://www.w3.org/1999/xlink"
                xmlns:stext="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.TextFactory"
                xmlns:simg="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.ImageIntrinsics"
                xmlns:suwl="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.UnwrapLinks"
                xmlns:ximg="xalan://com.nwalsh.xalan.ImageIntrinsics"
                xmlns:xtext="xalan://com.nwalsh.xalan.Text"
                xmlns:lxslt="http://xml.apache.org/xslt"
                exclude-result-prefixes="suwl xlink stext xtext lxslt simg ximg"
                extension-element-prefixes="stext xtext"

                version="1.0">

    <xsl:import href="@DOCBOOK_XSL@"/>
    <xsl:param name="release">@RELEASE@</xsl:param>
    <xsl:param name="use.extensions">0</xsl:param>
    <xsl:param name="use.id.as.filename">1</xsl:param>
    <xsl:param name="base.dir">./</xsl:param>
    <xsl:param name="make.valid.html">1</xsl:param>
    <xsl:param name="callout.graphics">0</xsl:param>
    <xsl:param name="callout.list.table">1</xsl:param>
    <xsl:param name="section.autolabel">1</xsl:param>
    <xsl:param name="generate.index">1</xsl:param>
    <xsl:param name="section.label.includes.component.label">1</xsl:param>
    <xsl:param name="chapter.autolabel">1</xsl:param>
    <xsl:param name="label.from.part">0</xsl:param>
    <xsl:param name="chunk.fast">1</xsl:param>
    <xsl:param name="chunker.output.indent">yes</xsl:param>
    <xsl:param name="chunker.output.encoding">UTF-8</xsl:param>
    <xsl:param name="chunk.first.sections">0</xsl:param>
    <xsl:param name="chunk.tocs.and.lots">0</xsl:param>
    <xsl:param name="chunk.section.depth">1</xsl:param>
    <xsl:param name="html.extra.head.links">1</xsl:param>
    <xsl:param name="generate.manifest">0</xsl:param>
    <xsl:param name="admon.graphics">1</xsl:param>
    <xsl:param name="admon.style"></xsl:param>
    <xsl:param name="html.stylesheet">
        syntaxhighlighter_3.0.83/styles/shCore.css
        syntaxhighlighter_3.0.83/styles/shThemeDefault.css
        styles.css
    </xsl:param>
    <xsl:param name="header.rule">0</xsl:param>
    <xsl:param name="footer.rule">0</xsl:param>
    <xsl:param name="htmlhelp.chm" select="'Chronicle_&lang;.chm'"/>
    <xsl:param name="htmlhelp.hhc.binary" select="0"/>
    <xsl:param name="htmlhelp.hhc.folders.instead.books" select="0"/>
    <xsl:param name="suppress.navigation" select="1"/>
    <xsl:param name="suppress.header.navigation" select="1"/>
    <xsl:param name="ulink.target">_blank</xsl:param>
    <xsl:param name="index.term.separator" select="' - '"/>
    <xsl:param name="section.label.includes.component.label" select="1"/>

    <!-- Table of Contents Configuration -->
    <!--
        The default generate.toc configuration:

        appendix  toc,title
        article/appendix  nop
        article   toc,title
        book      toc,title,figure,table,example,equation
        chapter   toc,title
        part      toc,title
        preface   toc,title
        qandadiv  toc
        qandaset  toc
        reference toc,title
        sect1     toc
        sect2     toc
        sect3     toc
        sect4     toc
        sect5     toc
        section   toc
        set       toc,title
    -->
    <xsl:param name="toc.section.depth" select="1"/>
    <xsl:param name="toc.max.depth" select="2"/>
    <xsl:param name="generate.toc">
        appendix  nop
        article/appendix  nop
        article   nop
        book      toc
        chapter   toc
        part      toc
        preface   nop
        qandadiv  nop
        qandaset  nop
        reference nop
        sect1     nop
        sect2     nop
        sect3     nop
        sect4     nop
        sect5     nop
        section   toc,title
        set       nop
    </xsl:param>

    <!-- breadcrumbs template -->
    <xsl:template name="breadcrumbs">
        <xsl:param name="prev" select="/foo"/>
        <xsl:param name="next" select="/foo"/>
        <xsl:param name="this.node" select="."/>
<div class="breadcrumbs">
    <span class="prev-next-nav">
        <xsl:choose>
            <xsl:when test="count($prev)>0">
                <a accesskey="p" class="prev">
                <xsl:attribute name="href">
                    <xsl:call-template name="href.target">
                        <xsl:with-param name="object" select="$prev"/>
                    </xsl:call-template>
                </xsl:attribute>
                <xsl:attribute name="title">
                    <xsl:apply-templates select="$prev" mode="object.title.markup"/>
                </xsl:attribute>
                <xsl:call-template name="navig.content">
                    <xsl:with-param name="direction" select="'prev'"/>
                </xsl:call-template>
                </a>
            </xsl:when>
            <xsl:otherwise>
                <span class="disabled">
                    <xsl:call-template name="navig.content">
                        <xsl:with-param name="direction" select="'prev'"/>
                    </xsl:call-template>
                </span>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text> | </xsl:text>
        <xsl:choose>
            <xsl:when test="count($next)>0">
                <a accesskey="n" class="next">
                <xsl:attribute name="href">
                    <xsl:call-template name="href.target">
                        <xsl:with-param name="object" select="$next"/>
                    </xsl:call-template>
                </xsl:attribute>
                <xsl:attribute name="title">
                    <xsl:apply-templates select="$next" mode="object.title.markup"/>
                </xsl:attribute>
                <xsl:call-template name="navig.content">
                    <xsl:with-param name="direction" select="'next'"/>
                </xsl:call-template>
                </a>
            </xsl:when>
            <xsl:otherwise>
                <span class="disabled">
                    <xsl:call-template name="navig.content">
                        <xsl:with-param name="direction" select="'next'"/>
                    </xsl:call-template>
                </span>
            </xsl:otherwise>
        </xsl:choose>
    </span>
    <xsl:for-each select="$this.node/ancestor::*">
        <span class="breadcrumb-link">
            <a>
            <xsl:attribute name="href">
                <xsl:call-template name="href.target">
                <xsl:with-param name="object" select="."/>
                <xsl:with-param name="context" select="$this.node"/>
                </xsl:call-template>
            </xsl:attribute>
            <xsl:apply-templates select="." mode="title.markup"/>
            </a>
        </span>
        <xsl:text> &gt; </xsl:text>
    </xsl:for-each>
    <!-- And display the current node, but not as a link -->
    <span class="breadcrumb-node">
        <xsl:apply-templates select="$this.node" mode="title.markup"/>
    </span>

</div>
    </xsl:template>

    <!-- determine if the current node belongs to the current part -->
    <xsl:template name="p4cms.part.active">
        <xsl:param name="ancestor"/>
        <xsl:param name="title"/>
        <xsl:if test="$ancestor = $title">active</xsl:if>
    </xsl:template>

    <!-- list the defined parts in this book in li tags for navigation -->
    <xsl:template name="p4cms.part.list">
    <xsl:param name="this.ancestor" select="(ancestor::part[1] | .)/title"/>
        <xsl:for-each select="//part">
            <li>
                <xsl:attribute name="class">
                    <xsl:call-template name="p4cms.part.active">
                        <xsl:with-param name="ancestor" select="$this.ancestor"/>
                        <xsl:with-param name="title" select="title"/>
                    </xsl:call-template>
                </xsl:attribute>
                <a>
                    <xsl:attribute name="href">
                        <xsl:call-template name="href.target">
                            <xsl:with-param name="object" select="."/>
                            <xsl:with-param name="context" select="."/>
                        </xsl:call-template>
                    </xsl:attribute>
                    <xsl:apply-templates select="." mode="title.markup"/>
                </a>
            </li>
        </xsl:for-each>
    </xsl:template>

    <!-- custom header navigation markup -->
    <xsl:template name="header.navigation">
        <xsl:param name="prev" select="/foo"/>
        <xsl:param name="next" select="/foo"/>
        <xsl:param name="nav.context"/>
        <xsl:variable name="home" select="/*[1]"/>
        <xsl:variable name="up" select="parent::*"/>
<div id="header">
    <div class="container header">
        <ul id="nav">
            <li class="logo"><img src="images/logo.png" alt="Chronicle"/></li>
            <li><a href="index.html" title="Return to Documentation Home">Documentation&#xA0;Home</a></li>
            <xsl:call-template name="p4cms.part.list"/>
        </ul>
    </div>
    <xsl:call-template name="breadcrumbs">
        <xsl:with-param name="prev" select="$prev"/>
        <xsl:with-param name="next" select="$next"/>
    </xsl:call-template>
</div>
    </xsl:template>

    <!-- custom footer navigation markup -->
    <xsl:template name="footer.navigation">
        <xsl:param name="prev" select="/foo"/>
        <xsl:param name="next" select="/foo"/>
        <xsl:param name="nav.context"/>
        <xsl:variable name="home" select="/*[1]"/>
        <xsl:variable name="up" select="parent::*"/>
        <xsl:call-template name="breadcrumbs">
            <xsl:with-param name="prev" select="$prev"/>
            <xsl:with-param name="next" select="$next"/>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="user.header.navigation">
        <!-- stuff put here appears before the top navigation area -->
    </xsl:template>

    <xsl:template name="user.footer.navigation">
        <!-- stuff put here appears after the bottom navigation area -->
        <xsl:element name="div">
            <xsl:attribute name="class">revinfo</xsl:attribute>
            <xsl:element name="a">
                <xsl:attribute name="href">http://www.perforcechronicle.com/</xsl:attribute>
                <xsl:text>Perforce Chronicle</xsl:text>
            </xsl:element>
            <xsl:text> - Release: </xsl:text>
            <xsl:value-of select="$release"/>
        </xsl:element>
    </xsl:template>

    <xsl:template match="release">
        <xsl:value-of select="$release"/>
    </xsl:template>

    <!-- custom class for sections containing sidebars -->
    <xsl:template match="mediaobjectco" mode="class.value">
        <xsl:value-of select="'mediaobjectco '"/>
        <xsl:value-of select="@role"/>
    </xsl:template>

    <!-- custom class for sections containing sidebars -->
    <xsl:template match="section[@role = 'sidebar']" mode="class.value">
        <xsl:value-of select="'section has-sidebar'"/>
    </xsl:template>

    <!-- custom class for sidebar lists -->
    <xsl:template match="itemizedlist[@role = 'bullet']" mode="class.value">
        <xsl:value-of select="'itemizedlist bullet'"/>
    </xsl:template>

    <!-- include a linebreak directive -->
    <xsl:template match="processing-instruction('linebreak')">
<br/>
    </xsl:template>

    <!-- make acronyms useful by fetching the glossary defininition for the title attribute -->
    <xsl:key name="glossreg" match="glossentry" use="@id"/>
    <xsl:template match="acronym">
        <xsl:param name="id" select="."/>
        <acronym>
            <xsl:attribute name="title"><xsl:value-of select="key('glossreg', $id)/glossdef/para"/></xsl:attribute>
        <xsl:value-of select="."/></acronym>
    </xsl:template>

    <!-- make a template for terms that appear in the glossary, so we can make them useful
         like we did for acronyms -->
    <xsl:template match="term4gloss">
        <xsl:param name="id" select="."/>
        <xsl:variable name="lowerid">
            <xsl:call-template name="string.lower">
                <xsl:with-param name="string" select="normalize-space(translate($id, ',./?&lt;&gt;&amp;&quot;`~[]{};:!@#$%^*()-_=+\|', ''))"/>
            </xsl:call-template>
        </xsl:variable>
        <span class="glossterm">
            <xsl:attribute name="title"><xsl:value-of select="key('glossreg', $lowerid)/glossdef/para"/></xsl:attribute>
        <xsl:value-of select="."/></span>
    </xsl:template>

    <!-- disable title attributes. This is heavy-handed, since it disables
         them in some places where they are expected, but makes the overall
         experience better. -->
    <xsl:template name="generate.html.title"/>


    <!-- customize the presentation of chunked sections by including the chapter title -->
<!--
    <xsl:template match="sect1/title
                        |sect1/info/title
                        |sect1info/title" 
                  mode="titlepage.mode" priority="2">
        <h2 class="chapter-title">
            Chapter <xsl:apply-templates select="ancestor::chapter" mode="label.markup"/>.
            <xsl:value-of select="ancestor::chapter/title"/>
        </h2>
        <xsl:call-template name="section.title"/>
    </xsl:template>
-->

    <!-- Embed SyntaxHighlighter, and other javascript -->
    <xsl:template name="user.head.content">
        <link rel="stylesheet" media="print" href="print.css" type="text/css"/>
        <script type="text/javascript" src="jquery-1.6.2.min.js"></script>
        <script type="text/javascript" src="docs.js"></script>
        <script type="text/javascript" src="xregexp-min.js"></script>
        <script type="text/javascript" src="syntaxhighlighter_3.0.83/src/shCore.js"></script>
        <script type="text/javascript" src="syntaxhighlighter_3.0.83/scripts/shBrushPhp.js"></script>
        <script type="text/javascript" src="shBrushCss.js"></script>
        <script type="text/javascript" src="shBrushIni.js"></script>
        <xsl:call-template name="conditional-comment">
            <!-- The 'qualifier' is the version of IE you want to target this is any version less than IE8 -->
            <xsl:with-param name="qualifier" select="'IE'"/>
            <!-- The 'contentRTF' contains the link tag with attributes -->
            <xsl:with-param name="contentRTF">&lt;link rel="stylesheet" type="text/css" href="ie7.css" /&gt;</xsl:with-param>
        </xsl:call-template>
    </xsl:template>

    <!-- The template that prints the IE conditional comment with the parameters above -->
    <xsl:template name="conditional-comment">
        <xsl:param name="qualifier"/>
        <xsl:param name="contentRTF"/>
        <xsl:comment>[if <xsl:value-of select="$qualifier"/>]<![CDATA[>]]><xsl:copy-of select="$contentRTF" /><![CDATA[<![endif]]]></xsl:comment>
    </xsl:template>

    <xsl:template name="user.footer.content">
<script type="text/javascript">//&lt;![CDATA[
    SyntaxHighlighter.defaults['toolbar'] = false;
    SyntaxHighlighter.all();
//]]&gt;</script>
    </xsl:template>

    <xsl:template match="programlisting[@language = 'php']" mode="class.value">
        <xsl:value-of select="'programlisting brush: php'"/>
    </xsl:template>
    <xsl:template match="programlisting[@language = 'css']" mode="class.value">
        <xsl:value-of select="'programlisting brush: css'"/>
    </xsl:template>
    <xsl:template match="programlisting[@language = 'xml']" mode="class.value">
        <xsl:value-of select="'programlisting brush: xml'"/>
    </xsl:template>
    <xsl:template match="programlisting[@language = 'ini']" mode="class.value">
        <xsl:value-of select="'programlisting brush: ini'"/>
    </xsl:template>

    <!-- customized callout handling -->
    <xsl:template match="callout">
    <xsl:choose>
        <xsl:when test="$callout.list.table != 0">
        <tr>
            <xsl:call-template name="tr.attributes">
            <xsl:with-param name="rownum">
                <xsl:number from="calloutlist" count="callout"/>
            </xsl:with-param>
            </xsl:call-template>

            <td width="5%" valign="top" align="{$direction.align.start}">
                <xsl:attribute name="class">
                    <xsl:value-of select="@arearefs"/>
                </xsl:attribute>
                <p>
                    <xsl:call-template name="anchor"/>
                    <a>
                        <xsl:attribute name="href">
                            <xsl:value-of select="'#'"/>
                        </xsl:attribute>
                        <xsl:call-template name="callout.arearefs">
                            <xsl:with-param name="arearefs" select="@arearefs"/>
                        </xsl:call-template>
                    </a>
                </p>
            </td>
            <td valign="top" align="{$direction.align.start}">
                <xsl:attribute name="class">
                    <xsl:value-of select="@arearefs"/>
                </xsl:attribute>
                <a>
                    <xsl:attribute name="href">
                        <xsl:value-of select="'#'"/>
                    </xsl:attribute>
                    <xsl:apply-templates/>
                </a>
            </td>
        </tr>
        </xsl:when>
        <xsl:otherwise>
        <dt>
            <xsl:attribute name="class">
                <xsl:value-of select="@arearefs"/>
            </xsl:attribute>
            <xsl:call-template name="anchor"/>
            <a>
                <xsl:attribute name="href">
                    <xsl:value-of select="'#'"/>
                </xsl:attribute>
                <xsl:call-template name="callout.arearefs">
                    <xsl:with-param name="arearefs" select="@arearefs"/>
                </xsl:call-template>
            </a>
        </dt>
        <dd>
            <xsl:attribute name="class">
                <xsl:value-of select="@arearefs"/>
            </xsl:attribute>
            <a>
                <xsl:attribute name="href">
                    <xsl:value-of select="'#'"/>
                </xsl:attribute>
                <xsl:apply-templates/>
            </a>
        </dd>
        </xsl:otherwise>
    </xsl:choose>
    </xsl:template>

    <!-- customize the handling of area tags generated for mediaobjectco areasets.
         Unfortunately, DB4.5 didn't bother to make this any more fine-grained that this
         800 line chunk of stylesheet.
    -->
<xsl:template name="process.image">
  <!-- When this template is called, the current node should be  -->
  <!-- a graphic, inlinegraphic, imagedata, or videodata. All    -->
  <!-- those elements have the same set of attributes, so we can -->
  <!-- handle them all in one place.                             -->
  <xsl:param name="tag" select="'img'"/>
  <xsl:param name="alt"/>
  <xsl:param name="longdesc"/>

  <!-- The HTML img element only supports the notion of content-area
       scaling; it doesn't support the distinction between a
       content-area and a viewport-area, so we have to make some
       compromises.

       1. If only the content-area is specified, everything is fine.
          (If you ask for a three inch image, that's what you'll get.)

       2. If only the viewport-area is provided:
          - If scalefit=1, treat it as both the content-area and
            the viewport-area. (If you ask for an image in a five inch
            area, we'll make the image five inches to fill that area.)
          - If scalefit=0, ignore the viewport-area specification.

          Note: this is not quite the right semantic and has the additional
          problem that it can result in anamorphic scaling, which scalefit
          should never cause.

       3. If both the content-area and the viewport-area is specified
          on a graphic element, ignore the viewport-area.
          (If you ask for a three inch image in a five inch area, we'll assume
           it's better to give you a three inch image in an unspecified area
           than a five inch image in a five inch area.

       Relative units also cause problems. As a general rule, the stylesheets
       are operating too early and too loosely coupled with the rendering engine
       to know things like the current font size or the actual dimensions of
       an image. Therefore:

       1. We use a fixed size for pixels, $pixels.per.inch

       2. We use a fixed size for "em"s, $points.per.em

       Percentages are problematic. In the following discussion, we speak
       of width and contentwidth, but the same issues apply to depth and
       contentdepth

       1. A width of 50% means "half of the available space for the image."
          That's fine. But note that in HTML, this is a dynamic property and
          the image size will vary if the browser window is resized.

       2. A contentwidth of 50% means "half of the actual image width". But
          the stylesheets have no way to assess the image's actual size. Treating
          this as a width of 50% is one possibility, but it produces behavior
          (dynamic scaling) that seems entirely out of character with the
          meaning.

          Instead, the stylesheets define a $nominal.image.width
          and convert percentages to actual values based on that nominal size.

       Scale can be problematic. Scale applies to the contentwidth, so
       a scale of 50 when a contentwidth is not specified is analagous to a
       width of 50%. (If a contentwidth is specified, the scaling factor can
       be applied to that value and no problem exists.)

       If scale is specified but contentwidth is not supplied, the
       nominal.image.width is used to calculate a base size
       for scaling.

       Warning: as a consequence of these decisions, unless the aspect ratio
       of your image happens to be exactly the same as (nominal width / nominal height),
       specifying contentwidth="50%" and contentdepth="50%" is NOT going to
       scale the way you expect (or really, the way it should).

       Don't do that. In fact, a percentage value is not recommended for content
       size at all. Use scale instead.

       Finally, align and valign are troublesome. Horizontal alignment is now
       supported by wrapping the image in a <div align="{@align}"> (in block
       contexts!). I can't think of anything (practical) to do about vertical
       alignment.
  -->

  <xsl:variable name="width-units">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0"></xsl:when>
      <xsl:when test="@width">
        <xsl:call-template name="length-units">
          <xsl:with-param name="length" select="@width"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="not(@depth) and $default.image.width != ''">
        <xsl:call-template name="length-units">
          <xsl:with-param name="length" select="$default.image.width"/>
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="width">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0"></xsl:when>
      <xsl:when test="@width">
        <xsl:choose>
          <xsl:when test="$width-units = '%'">
            <xsl:value-of select="@width"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="length-spec">
              <xsl:with-param name="length" select="@width"/>
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:when test="not(@depth) and $default.image.width != ''">
        <xsl:value-of select="$default.image.width"/>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="scalefit">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0">0</xsl:when>
      <xsl:when test="@contentwidth or @contentdepth">0</xsl:when>
      <xsl:when test="@scale">0</xsl:when>
      <xsl:when test="@scalefit"><xsl:value-of select="@scalefit"/></xsl:when>
      <xsl:when test="$width != '' or @depth">1</xsl:when>
      <xsl:otherwise>0</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="scale">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0">1.0</xsl:when>
      <xsl:when test="@contentwidth or @contentdepth">1.0</xsl:when>
      <xsl:when test="@scale">
        <xsl:value-of select="@scale div 100.0"/>
      </xsl:when>
      <xsl:otherwise>1.0</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="filename">
    <xsl:choose>
      <xsl:when test="local-name(.) = 'graphic'
                      or local-name(.) = 'inlinegraphic'">
        <!-- handle legacy graphic and inlinegraphic by new template --> 
        <xsl:call-template name="mediaobject.filename">
          <xsl:with-param name="object" select="."/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <!-- imagedata, videodata, audiodata -->
        <xsl:call-template name="mediaobject.filename">
          <xsl:with-param name="object" select=".."/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="output_filename">
    <xsl:choose>
      <xsl:when test="@entityref">
        <xsl:value-of select="$filename"/>
      </xsl:when>
      <!--
        Moved test for $keep.relative.image.uris to template below:
            <xsl:template match="@fileref">
      -->
      <xsl:otherwise>
        <xsl:value-of select="$filename"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="img.src.path.pi">
    <xsl:call-template name="pi.dbhtml_img.src.path">
      <xsl:with-param name="node" select=".."/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="filename.for.graphicsize">
    <xsl:choose>
      <xsl:when test="$img.src.path.pi != ''">
        <xsl:value-of select="concat($img.src.path.pi, $filename)"/>
      </xsl:when>
      <xsl:when test="$img.src.path != '' and
                      $graphicsize.use.img.src.path != 0 and
                      $tag = 'img' and
                      not(starts-with($filename, '/')) and
                      not(contains($filename, '://'))">
        <xsl:value-of select="concat($img.src.path, $filename)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$filename"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="realintrinsicwidth">
    <!-- This funny compound test works around a bug in XSLTC -->
    <xsl:choose>
      <xsl:when test="$use.extensions != 0 and $graphicsize.extension != 0">
        <xsl:choose>
          <xsl:when test="function-available('simg:getWidth')">
            <xsl:value-of select="simg:getWidth(simg:new($filename.for.graphicsize),
                                                $nominal.image.width)"/>
          </xsl:when>
          <xsl:when test="function-available('ximg:getWidth')">
            <xsl:value-of select="ximg:getWidth(ximg:new($filename.for.graphicsize),
                                                $nominal.image.width)"/>
          </xsl:when>
          <xsl:otherwise>
           <xsl:value-of select="0"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="0"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="intrinsicwidth">
    <xsl:choose>
      <xsl:when test="$realintrinsicwidth = 0">
       <xsl:value-of select="$nominal.image.width"/>
      </xsl:when>
      <xsl:otherwise>
       <xsl:value-of select="$realintrinsicwidth"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="intrinsicdepth">
    <!-- This funny compound test works around a bug in XSLTC -->
    <xsl:choose>
      <xsl:when test="$use.extensions != 0 and $graphicsize.extension != 0">
        <xsl:choose>
          <xsl:when test="function-available('simg:getDepth')">
            <xsl:value-of select="simg:getDepth(simg:new($filename.for.graphicsize),
                                                $nominal.image.depth)"/>
          </xsl:when>
          <xsl:when test="function-available('ximg:getDepth')">
            <xsl:value-of select="ximg:getDepth(ximg:new($filename.for.graphicsize),
                                                $nominal.image.depth)"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$nominal.image.depth"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$nominal.image.depth"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="contentwidth">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0"></xsl:when>
      <xsl:when test="@contentwidth">
        <xsl:variable name="units">
          <xsl:call-template name="length-units">
            <xsl:with-param name="length" select="@contentwidth"/>
          </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
          <xsl:when test="$units = '%'">
            <xsl:variable name="cmagnitude">
              <xsl:call-template name="length-magnitude">
                <xsl:with-param name="length" select="@contentwidth"/>
              </xsl:call-template>
            </xsl:variable>
            <xsl:value-of select="$intrinsicwidth * $cmagnitude div 100.0"/>
            <xsl:text>px</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="length-spec">
              <xsl:with-param name="length" select="@contentwidth"/>
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$intrinsicwidth"/>
        <xsl:text>px</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="scaled.contentwidth">
    <xsl:if test="$contentwidth != ''">
      <xsl:variable name="cwidth.in.points">
        <xsl:call-template name="length-in-points">
          <xsl:with-param name="length" select="$contentwidth"/>
          <xsl:with-param name="pixels.per.inch" select="$pixels.per.inch"/>
          <xsl:with-param name="em.size" select="$points.per.em"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:value-of select="$cwidth.in.points div 72.0 * $pixels.per.inch * $scale"/>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="html.width">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0"></xsl:when>
      <xsl:when test="$width-units = '%'">
        <xsl:value-of select="$width"/>
      </xsl:when>
      <xsl:when test="$width != ''">
        <xsl:variable name="width.in.points">
          <xsl:call-template name="length-in-points">
            <xsl:with-param name="length" select="$width"/>
            <xsl:with-param name="pixels.per.inch" select="$pixels.per.inch"/>
            <xsl:with-param name="em.size" select="$points.per.em"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="round($width.in.points div 72.0 * $pixels.per.inch)"/>
      </xsl:when>
      <xsl:otherwise></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="contentdepth">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0"></xsl:when>
      <xsl:when test="@contentdepth">
        <xsl:variable name="units">
          <xsl:call-template name="length-units">
            <xsl:with-param name="length" select="@contentdepth"/>
          </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
          <xsl:when test="$units = '%'">
            <xsl:variable name="cmagnitude">
              <xsl:call-template name="length-magnitude">
                <xsl:with-param name="length" select="@contentdepth"/>
              </xsl:call-template>
            </xsl:variable>
            <xsl:value-of select="$intrinsicdepth * $cmagnitude div 100.0"/>
            <xsl:text>px</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="length-spec">
              <xsl:with-param name="length" select="@contentdepth"/>
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$intrinsicdepth"/>
        <xsl:text>px</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="scaled.contentdepth">
    <xsl:if test="$contentdepth != ''">
      <xsl:variable name="cdepth.in.points">
        <xsl:call-template name="length-in-points">
          <xsl:with-param name="length" select="$contentdepth"/>
          <xsl:with-param name="pixels.per.inch" select="$pixels.per.inch"/>
          <xsl:with-param name="em.size" select="$points.per.em"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:value-of select="$cdepth.in.points div 72.0 * $pixels.per.inch * $scale"/>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="depth-units">
    <xsl:if test="@depth">
      <xsl:call-template name="length-units">
        <xsl:with-param name="length" select="@depth"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="depth">
    <xsl:if test="@depth">
      <xsl:choose>
        <xsl:when test="$depth-units = '%'">
          <xsl:value-of select="@depth"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="length-spec">
            <xsl:with-param name="length" select="@depth"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="html.depth">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0"></xsl:when>
      <xsl:when test="$depth-units = '%'">
        <xsl:value-of select="$depth"/>
      </xsl:when>
      <xsl:when test="@depth and @depth != ''">
        <xsl:variable name="depth.in.points">
          <xsl:call-template name="length-in-points">
            <xsl:with-param name="length" select="$depth"/>
            <xsl:with-param name="pixels.per.inch" select="$pixels.per.inch"/>
            <xsl:with-param name="em.size" select="$points.per.em"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="round($depth.in.points div 72.0 * $pixels.per.inch)"/>
      </xsl:when>
      <xsl:otherwise></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="viewport">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0">0</xsl:when>
      <xsl:when test="local-name(.) = 'inlinegraphic'
                      or ancestor::inlinemediaobject
                      or ancestor::inlineequation">0</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$make.graphic.viewport"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

<!--
  <xsl:message>=====================================
scale: <xsl:value-of select="$scale"/>, <xsl:value-of select="$scalefit"/>
@contentwidth <xsl:value-of select="@contentwidth"/>
$contentwidth <xsl:value-of select="$contentwidth"/>
scaled.contentwidth: <xsl:value-of select="$scaled.contentwidth"/>
@width: <xsl:value-of select="@width"/>
width: <xsl:value-of select="$width"/>
html.width: <xsl:value-of select="$html.width"/>
@contentdepth <xsl:value-of select="@contentdepth"/>
$contentdepth <xsl:value-of select="$contentdepth"/>
scaled.contentdepth: <xsl:value-of select="$scaled.contentdepth"/>
@depth: <xsl:value-of select="@depth"/>
depth: <xsl:value-of select="$depth"/>
html.depth: <xsl:value-of select="$html.depth"/>
align: <xsl:value-of select="@align"/>
valign: <xsl:value-of select="@valign"/></xsl:message>
-->

  <xsl:variable name="scaled"
              select="@width|@depth|@contentwidth|@contentdepth
                        |@scale|@scalefit"/>

  <xsl:variable name="img">
    <xsl:choose>
      <xsl:when test="@format = 'SVG'">
        <object type="image/svg+xml">
      <xsl:attribute name="data">
        <xsl:choose>
          <xsl:when test="$img.src.path != '' and
                           $tag = 'img' and
               not(starts-with($output_filename, '/')) and
               not(contains($output_filename, '://'))">
        <xsl:value-of select="$img.src.path"/>
          </xsl:when>
           </xsl:choose>
       <xsl:value-of select="$output_filename"/>
      </xsl:attribute>
      <xsl:call-template name="process.image.attributes">
            <!--xsl:with-param name="alt" select="$alt"/ there's no alt here-->
            <xsl:with-param name="html.depth" select="$html.depth"/>
            <xsl:with-param name="html.width" select="$html.width"/>
            <xsl:with-param name="longdesc" select="$longdesc"/>
            <xsl:with-param name="scale" select="$scale"/>
            <xsl:with-param name="scalefit" select="$scalefit"/>
            <xsl:with-param name="scaled.contentdepth" select="$scaled.contentdepth"/>
            <xsl:with-param name="scaled.contentwidth" select="$scaled.contentwidth"/>
            <xsl:with-param name="viewport" select="$viewport"/>
          </xsl:call-template>
          <xsl:if test="@align">
            <xsl:attribute name="align">
                <xsl:choose>
                  <xsl:when test="@align = 'center'">middle</xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="@align"/>
                  </xsl:otherwise>
                </xsl:choose>
            </xsl:attribute>
          </xsl:if>
          <xsl:if test="$use.embed.for.svg != 0">
        <embed type="image/svg+xml">
          <xsl:attribute name="src">
        <xsl:choose>
                  <xsl:when test="$img.src.path != '' and
                  $tag = 'img' and
                  not(starts-with($output_filename, '/')) and
                  not(contains($output_filename, '://'))">
            <xsl:value-of select="$img.src.path"/>
                  </xsl:when>
        </xsl:choose>
        <xsl:value-of select="$output_filename"/>
              </xsl:attribute>
              <xsl:call-template name="process.image.attributes">
                <!--xsl:with-param name="alt" select="$alt"/ there's no alt here -->
                <xsl:with-param name="html.depth" select="$html.depth"/>
                <xsl:with-param name="html.width" select="$html.width"/>
                <xsl:with-param name="longdesc" select="$longdesc"/>
                <xsl:with-param name="scale" select="$scale"/>
                <xsl:with-param name="scalefit" select="$scalefit"/>
                <xsl:with-param name="scaled.contentdepth" select="$scaled.contentdepth"/>
                <xsl:with-param name="scaled.contentwidth" select="$scaled.contentwidth"/>
                <xsl:with-param name="viewport" select="$viewport"/>
              </xsl:call-template>
            </embed>
          </xsl:if>
        </object>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="{$tag}">
         <xsl:if test="$tag = 'img' and ../../self::imageobjectco">
           <xsl:variable name="mapname">
             <xsl:call-template name="object.id">
               <xsl:with-param name="object" select="../../areaspec"/>
             </xsl:call-template>
           </xsl:variable>
           <xsl:choose>
             <xsl:when test="$scaled">
              <!-- It might be possible to handle some scaling; needs -->
              <!-- more investigation -->
              <xsl:message>
                <xsl:text>Warning: imagemaps not supported </xsl:text>
                <xsl:text>on scaled images</xsl:text>
              </xsl:message>
             </xsl:when>
             <xsl:otherwise>
              <xsl:attribute name="border">0</xsl:attribute>
              <xsl:attribute name="usemap">
                <xsl:value-of select="concat('#', $mapname)"/>
              </xsl:attribute>
             </xsl:otherwise>
           </xsl:choose>
         </xsl:if>

          <xsl:attribute name="src">
           <xsl:choose>
             <xsl:when test="$img.src.path != '' and
                           $tag = 'img' and
                             not(starts-with($output_filename, '/')) and
                           not(contains($output_filename, '://'))">
               <xsl:value-of select="$img.src.path"/>
             </xsl:when>
           </xsl:choose>
            <xsl:value-of select="$output_filename"/>
          </xsl:attribute>

          <xsl:if test="@align">
            <xsl:attribute name="align">
              <xsl:choose>
                <xsl:when test="@align = 'center'">middle</xsl:when>
                <xsl:otherwise>
                  <xsl:value-of select="@align"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:attribute>
          </xsl:if>

          <xsl:call-template name="process.image.attributes">
            <xsl:with-param name="alt">
              <xsl:choose>
                <xsl:when test="$alt != ''">
                  <xsl:copy-of select="$alt"/>
                </xsl:when>
                <xsl:when test="ancestor::figure">
                  <xsl:value-of select="normalize-space(ancestor::figure/title)"/>
                </xsl:when>
              </xsl:choose>
            </xsl:with-param>
            <xsl:with-param name="html.depth" select="$html.depth"/>
            <xsl:with-param name="html.width" select="$html.width"/>
            <xsl:with-param name="longdesc" select="$longdesc"/>
            <xsl:with-param name="scale" select="$scale"/>
            <xsl:with-param name="scalefit" select="$scalefit"/>
            <xsl:with-param name="scaled.contentdepth" select="$scaled.contentdepth"/>
            <xsl:with-param name="scaled.contentwidth" select="$scaled.contentwidth"/>
            <xsl:with-param name="viewport" select="$viewport"/>
          </xsl:call-template>
        </xsl:element>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="bgcolor">
    <xsl:call-template name="pi.dbhtml_background-color">
      <xsl:with-param name="node" select=".."/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="use.viewport"
                select="$viewport != 0
                        and ($html.width != ''
                             or ($html.depth != '' and $depth-units != '%')
                             or $bgcolor != ''
                             or @valign)"/>

  <xsl:choose>
    <xsl:when test="$use.viewport">
      <table border="0" summary="manufactured viewport for HTML img"
             cellspacing="0" cellpadding="0">
        <xsl:if test="$html.width != ''">
          <xsl:attribute name="width">
            <xsl:value-of select="$html.width"/>
          </xsl:attribute>
        </xsl:if>
        <tr>
          <xsl:if test="$html.depth != '' and $depth-units != '%'">
            <!-- don't do this for percentages because browsers get confused -->
            <xsl:choose>
              <xsl:when test="$css.decoration != 0">
                <xsl:attribute name="style">
                  <xsl:text>height: </xsl:text>
                  <xsl:value-of select="$html.depth"/>
                  <xsl:text>px</xsl:text>
                </xsl:attribute>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="height">
                  <xsl:value-of select="$html.depth"/>
                </xsl:attribute>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:if>
          <td>
            <xsl:if test="$bgcolor != ''">
              <xsl:choose>
                <xsl:when test="$css.decoration != 0">
                  <xsl:attribute name="style">
                    <xsl:text>background-color: </xsl:text>
                    <xsl:value-of select="$bgcolor"/>
                  </xsl:attribute>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:attribute name="bgcolor">
                    <xsl:value-of select="$bgcolor"/>
                  </xsl:attribute>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:if>
            <xsl:if test="@align">
              <xsl:attribute name="align">
                <xsl:value-of select="@align"/>
              </xsl:attribute>
            </xsl:if>
            <xsl:if test="@valign">
              <xsl:attribute name="valign">
                <xsl:value-of select="@valign"/>
              </xsl:attribute>
            </xsl:if>
            <xsl:copy-of select="$img"/>
          </td>
        </tr>
      </table>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$img"/>
    </xsl:otherwise>
  </xsl:choose>

  <xsl:if test="$tag = 'img' and ../../self::imageobjectco and not($scaled)">
    <xsl:variable name="mapname">
      <xsl:call-template name="object.id">
        <xsl:with-param name="object" select="../../areaspec"/>
      </xsl:call-template>
    </xsl:variable>

    <map name="{$mapname}">
      <xsl:for-each select="../../areaspec//area">
        <xsl:variable name="units">
          <xsl:choose>
            <xsl:when test="@units = 'other' and @otherunits">
              <xsl:value-of select="@otherunits"/>
            </xsl:when>
            <xsl:when test="@units">
              <xsl:value-of select="@units"/>
            </xsl:when>
            <!-- areaspec|areaset/area -->
            <xsl:when test="../@units = 'other' and ../@otherunits">
              <xsl:value-of select="../@otherunits"/>
            </xsl:when>
            <xsl:when test="../@units">
              <xsl:value-of select="../@units"/>
            </xsl:when>
            <!-- areaspec/areaset/area -->
            <xsl:when test="../../@units = 'other' and ../../@otherunits">
              <xsl:value-of select="../@otherunits"/>
            </xsl:when>
            <xsl:when test="../../@units">
              <xsl:value-of select="../../@units"/>
            </xsl:when>
            <xsl:otherwise>calspair</xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
 
        <xsl:choose>
          <xsl:when test="$units = 'calspair' or
                          $units = 'imagemap'">
            <xsl:variable name="coords" select="normalize-space(@coords)"/>

            <area shape="rect">
              <xsl:attribute name="id">
                <xsl:value-of select="@id"/>
              </xsl:attribute>
              <xsl:variable name="linkends">
                <xsl:choose>
                  <xsl:when test="@linkends">
                    <xsl:value-of select="normalize-space(@linkends)"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="normalize-space(../@linkends)"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
 
              <xsl:variable name="href">
                <xsl:choose>
                  <xsl:when test="@xlink:href">
                    <xsl:value-of select="@xlink:href"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="../@xlink:href"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
 
              <xsl:choose>
                <xsl:when test="$linkends != ''">
                  <xsl:variable name="linkend">
                    <xsl:choose>
                      <xsl:when test="contains($linkends, ' ')">
                        <xsl:value-of select="substring-before($linkends, ' ')"/>
                      </xsl:when>
                      <xsl:otherwise>
                        <xsl:value-of select="$linkends"/>
                      </xsl:otherwise>
                    </xsl:choose>
                  </xsl:variable>
                  
                  <xsl:variable name="target" select="key('id', $linkend)[1]"/>
                 
                  <xsl:if test="$target">
                    <xsl:attribute name="href">
                      <xsl:call-template name="href.target">
                        <xsl:with-param name="object" select="$target"/>
                      </xsl:call-template>
                    </xsl:attribute>
                  </xsl:if>
                </xsl:when>
                <xsl:when test="$href != ''">
                  <xsl:attribute name="href">
                    <xsl:value-of select="$href"/>
                  </xsl:attribute>
                </xsl:when>
              </xsl:choose>
 
              <xsl:if test="alt">
                <xsl:attribute name="alt">
                  <xsl:value-of select="alt[1]"/>
                </xsl:attribute>
              </xsl:if>
 
              <xsl:attribute name="coords">
                <xsl:choose>
                  <xsl:when test="$units = 'calspair'">

                    <xsl:variable name="p1"
                                select="substring-before($coords, ' ')"/>
                    <xsl:variable name="p2"
                                select="substring-after($coords, ' ')"/>
         
                    <xsl:variable name="x1" select="substring-before($p1,',')"/>
                    <xsl:variable name="y1" select="substring-after($p1,',')"/>
                    <xsl:variable name="x2" select="substring-before($p2,',')"/>
                    <xsl:variable name="y2" select="substring-after($p2,',')"/>
         
                    <xsl:variable name="x1p" select="$x1 div 100.0"/>
                    <xsl:variable name="y1p" select="$y1 div 100.0"/>
                    <xsl:variable name="x2p" select="$x2 div 100.0"/>
                    <xsl:variable name="y2p" select="$y2 div 100.0"/>
         
         <!--
                    <xsl:message>
                      <xsl:text>units: </xsl:text>
                      <xsl:value-of select="$units"/>
                      <xsl:text> </xsl:text>
                      <xsl:value-of select="$x1p"/><xsl:text>, </xsl:text>
                      <xsl:value-of select="$y1p"/><xsl:text>, </xsl:text>
                      <xsl:value-of select="$x2p"/><xsl:text>, </xsl:text>
                      <xsl:value-of select="$y2p"/><xsl:text>, </xsl:text>
                    </xsl:message>
         
                    <xsl:message>
                      <xsl:text>      </xsl:text>
                      <xsl:value-of select="$intrinsicwidth"/>
                      <xsl:text>, </xsl:text>
                      <xsl:value-of select="$intrinsicdepth"/>
                    </xsl:message>
         
                    <xsl:message>
                      <xsl:text>      </xsl:text>
                      <xsl:value-of select="$units"/>
                      <xsl:text> </xsl:text>
                      <xsl:value-of 
                            select="round($x1p * $intrinsicwidth div 100.0)"/>
                      <xsl:text>,</xsl:text>
                      <xsl:value-of select="round($intrinsicdepth
                                       - ($y2p * $intrinsicdepth div 100.0))"/>
                      <xsl:text>,</xsl:text>
                      <xsl:value-of select="round($x2p * 
                                            $intrinsicwidth div 100.0)"/>
                      <xsl:text>,</xsl:text>
                      <xsl:value-of select="round($intrinsicdepth
                                       - ($y1p * $intrinsicdepth div 100.0))"/>
                    </xsl:message>
         -->
                    <xsl:value-of 
                             select="round($x1p * $intrinsicwidth div 100.0)"/>
                    <xsl:text>,</xsl:text>
                    <xsl:value-of select="round($intrinsicdepth
                                        - ($y2p * $intrinsicdepth div 100.0))"/>
                    <xsl:text>,</xsl:text>
                    <xsl:value-of 
                             select="round($x2p * $intrinsicwidth div 100.0)"/>
                    <xsl:text>,</xsl:text>
                    <xsl:value-of select="round($intrinsicdepth
                                      - ($y1p * $intrinsicdepth div 100.0))"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:copy-of select="$coords"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:attribute>
            </area>
          </xsl:when>
          <xsl:otherwise>
            <xsl:message>
              <xsl:text>Warning: only calspair or </xsl:text>
              <xsl:text>otherunits='imagemap' supported </xsl:text>
              <xsl:text>in imageobjectco</xsl:text>
            </xsl:message>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:for-each>
    </map>
  </xsl:if>
</xsl:template>

    <xsl:template name="write.indexterm"/>

  <xsl:template match="mediaobject" mode="class.value">
    <xsl:choose>
      <xsl:when test="@role">
        <xsl:value-of select="'mediaobject '"/>
        <xsl:value-of select="@role"/>
      </xsl:when>
      <xsl:otherwise>mediaobject</xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- customize ulink to pass role attributes through as class attributes -->
  <xsl:template match="ulink" name="ulink">
    <xsl:param name="url" select="@url"/>
    <xsl:variable name="link">
      <a>
        <xsl:choose>
          <!-- We don't want empty @class values, so do not propagate empty @roles -->
          <xsl:when test="@role  and
                          normalize-space(@role) != '' and
                          $emphasis.propagates.style != 0">
            <xsl:apply-templates select="." mode="common.html.attributes">
              <xsl:with-param name="class" select="@role"/>
            </xsl:apply-templates>
          </xsl:when>
          <xsl:otherwise>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:if test="@id or @xml:id">
          <xsl:attribute name="name">
            <xsl:value-of select="(@id|@xml:id)[1]"/>
          </xsl:attribute>
        </xsl:if>
        <xsl:attribute name="href"><xsl:value-of select="$url"/></xsl:attribute>
        <xsl:if test="@onclick  and
                        normalize-space(@onclick) != ''">
            <xsl:attribute name="onclick"><xsl:value-of select="@onclick"/></xsl:attribute>
        </xsl:if>
        <xsl:attribute name="href"><xsl:value-of select="$url"/></xsl:attribute>
        <xsl:if test="$ulink.target != ''">
          <xsl:attribute name="target"><xsl:value-of select="$ulink.target"/></xsl:attribute>
        </xsl:if>
        <xsl:choose>
          <xsl:when test="count(child::node())=0">
            <xsl:value-of select="$url"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:apply-templates/>
          </xsl:otherwise>
        </xsl:choose>
      </a>
    </xsl:variable>

    <xsl:choose>
      <xsl:when test="function-available('suwl:unwrapLinks')">
        <xsl:copy-of select="suwl:unwrapLinks($link)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:copy-of select="$link"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

</xsl:stylesheet>
<!--
vim:se ts=2 sw=2 et:
-->